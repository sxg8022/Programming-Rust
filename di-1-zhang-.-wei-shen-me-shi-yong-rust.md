# 第1章. 为什么使用RUST

#### 第1章

## 为什么使用RUST

 _在某些情况下---例如RUST语言的生态环境目标--- 比竞争对手快2倍甚至10倍是成败的关键。 它决定了一个系统在市场上的命运，就像它在硬件市场上的命运一样。_

         —Graydon Hoare



  _现在所有的计算机都是并行计算的。。。_

  _并发编程才是现代真正的编程。_

         —Michael McCool et al., Structured Parallel Programming



  _TrueType 的解析器是有缺陷的_

  _这些缺陷会被骇客利用_

 _所有软件对安全都是很敏感的。_

         —Andy Wingo



 自从我们开始使用高级语言编写操作系统以来，系统编程语言在过去的50年里取得了长足的进步，但是有两个问题已经被证明是难以解决的：

* 想写安全的代码是很困难的。用C或者C++正确的管理内存是特别困难。开发者为此被折磨了几十年。 安全漏洞的问题至少可以追溯到1988年莫里斯蠕虫病毒。
* 开发多线程是很困难的，多线程是发掘现在计算机能力的唯一途径。 即使是有经验的程序员处理多线程代码也要小心：并发会大量引入新型的Bug类型，并且对于修复普通Bug也是很困难。

开启RUST：一门具有C和C++同等高性能，而且 安全，并发编程特性的现代开发语言。

RUST是一门全新的系统编程语言，它由Mozilla和开源社区爱好者共同开发设计的。像C和C++一样，RUST给与开发者良好的控制内存的能力，同时保持语言本身的操作能力与运行计算机之间的紧密关联，有助于开发者写出更高效的程序。RUST展示了它的野心，就像Bjarne Stroustrup在他的个人主页所表达的“抽象与C++机器模型”：

       通常，C++的实现准从零开销的原则：你用不到的功能，你不会损耗相应的性能。并且进一步讲：你手写的代码，就是最优的。

对于RUST来说，在拥有以上C++优点的同时，还具有内存安全和可靠并发编程的特点。

实现RUST系统独有的所有权，移动和借用功能关键是实现编译时的检查和合理的设计，这是静态灵活的RUST系统核心所在。对于内核语言来说，所有权确立了每个对象的生命周期，这样可以准确的释放无效的内存对象，所以内存的垃圾回收功能就不需要了，并且可以灵活的支持其他类型的接口：套接字和文件句柄。移动功能就是把一个对象的所有权移动给另一个对象，并且 借用允许代码使用一个对象的临时值而不影响这个对象的所有权。在此之前，由于许多程序都不会有这种特性的需求，所以我们在第4和5章节详细讲解这些内容。

 这些相同的所有权规则也构成了Rust可信赖并发模型的基础。大部分的语言需要用详细的注释来说明互斥锁和其要保护数据的之间关系。RUST有能力在编译时检查你是否能获得相关对象的互斥锁。大部分语言都会警告你，在把一个结构对象传给另一个线程后，一定不要再操作这个结构对象；RUST语言会在编译时检查这些，你无需关心。RUST可以在编译时预防数据并发访问问题。

RUST并不是一个面向对象类型的编程语言，尽管RUST具有一些面向对象的特性。RUST也不是一门函数式的编程语言，尽管它确实会像函数语言那样处理问题，尤其是对计算结果的影响。 Rust在某种程度上类似于C和c++，但是这些语言中的许多习惯用法并不适用，因此典型的Rust代码与C或c++代码并不十分相似。对于RUST是什么样的语言，我们保留建议，一旦你适应了RUST，你就会有自己的答案了。

 Mozilla用RUST开发了新的web浏览器引擎Servo，这样的实战可以印证RUST的设计，反馈RUST的设计问题。Servo的需求和RUST的目标是非常吻合的： 浏览器必须稳定的运行，并安全地处理不受信任的数据。Servo利用RUST的安全性和并发特性处理计算机上所有的任务，而这些任务用C或者C++无法并行处理。事实上，Servo和RUST一起成长 了，Servo获得了语言的最新特性，而且基于Servo开发人员的反馈，RUST也获得了改进和优化。

### 类型安全

RUST是一门类型安全的语言，但是我们所说的“类型安全”到底是什么意思？安全听起来是好的，但究竟是什么机制让我们写的代码保持安全的？

 这是1999年C编程语言标准C99规范中关于“未定义”行为的定义：

          **未定义行为**

          ****使用了不可移植或错误的程序架构，或者错误数据的行为，但是国际标准并没有对这些行为做明确的定义和说明。

思考下面的C代码：

```c
int main(int argc, char **argv) {
  unsigned long a[1];
  a[3] = 0x7ffff7b36cebUL;
  return 0;
}
```

根据C99的规范，因为程序访问了超过数组的范围，也就是数组越界，这个行为是未定义的，意味着它可以不受控制的访问不该访问的内存地址，在Jim的笔记本上运行这个程序，它输出了以下信息：

```c
undef: Error: .netrc file is readable by others.
undef: Remove password or make file unreadable by others.
```

然后，这个程序崩溃了。Jim的笔记本上根本就没有 .netrc 这个文件。如果你自己尝试运行这个代码，它可能产生完全不同的结果输出。

C编译器为这个main函数生成字节码，编译器为数组a分配的堆栈地址恰好在函数返回的前的3个字，这样存储在 a\[3\]中的  0x7ffff7b36cebUL  会改变main函数的返回地址，返回地址会指向C的标准库代码，这段代码的功能是 查阅 .netrc 文件以获得密码。当main返回的实时，代码并没有按预期返回到main函数调用者的内存地址空间中，所以系统为这些未定义行为代码产生了如下处理代码：

```c
warnx(_("Error: .netrc file is readable by others."));
warnx(_("Remove password or make file unreadable by others."));
goto bad;
```

允许数组访问影响后续返回地址，对于C编译器来说是完全符合规范的。一个未定义的操作并不会产生一个不确定的结果：它运行程序做任何事情。

C99赋予编译器全部的权力，目的是让它产生更高性能的代码。检查和处理例如数组越界这样的老问题，标准规定由开发人负责处理，而不是由编译器负责。

就经验来说， 我们不太擅长这个。当我还在犹他州大学上学的时候，李鹏研究员修改了C和C++编译器，当程序执行某些未定义行为时，编译器可以把这些未定义行为转换给相应的输出信息。他发现几乎所有的程序都是这样处理的，包括那些代码质量保持高标准的伟大项目。在实践中，一个未定义的行为会产生安全漏洞，此安全漏洞可能被骇客利用攻击系统。莫里斯蠕虫病毒就是利用前面说的安全漏洞，采用精妙的设计，自身可以实现从一台机器到多台机器自动的传播。这种病毒的实现的方式至今还在被广泛的使用。

根据这个例子，让我们定义一些术语。如果一个程序已经被编写好，并且运行中也没有未定义的行为出现，我们可以说这个程序是一个定义很好的程序。如果一门语言的安全检测可以确保用这门语言写的每一个程序都是很好定义的，那么我们可以说这门语言是类型安全的语言。

一个精心设计的C或C++程序可以有很好的定义，但是C和C++不是一门类型安全的语言：前面写的例子程序没有类型错误，但是确显示了未定义行为的错误。与之相比，Python是类型安全的。Python是以牺牲处理器性能的代经来检查处理数组越界的问题，比C更友好的方式指示这类未定义行为的错误：

```python
>>> a = [0]
>>> a[3] = 0x7ffff7b36ceb
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
IndexError: list assignment index out of range
>>>
```

Python会触发一个异常，指出一个未定义的行为：如我们看到的，这个Python文档详细说明了，给a\[3\]赋值应当触发一个IndexError异常。当然，为ctypes模块提供不受约束的访问计算机的能力，也会为Python引入未定义的行为，当这个语言的核心还是类型安全的。Java, JavaScript, Ruby, 和Haskell同Python的类型安全时形似的。

注意，语言的类型安全与在编译时检测还是在运行时检测是无关的：C是在编译时检测，它不是类型安全的语言，Python是在运行时检测，它是类型安全的语言。

具有讽刺意味的是占有主导地位的系统编程语言，C和C++都是不是类型安全的，然而大部分流行的编程语言确是类型安全的。由于C和C++是用于实现系统的基础功能，实现安全边界并且处理不受信任的数据，类型安全对于系统来说特别重要的意义。

这就是数十年RUST的目标和决心：成为类型安全而且是系统编程语言。设计RUST的目标是实现系统层面的基础功能，要求对资源具有高效而且精细的控制，还要确保类型安全的基本可预期。在本书后面的章节中，我们将看到RUST如何管理这种安全一致性。

RUST独特的类型安全形式为多线程编程提供了令人匪夷所思的效果。对于C和C++的并发编程是众所周知的困难；开发人员通常只有在单线程无法满足性能要求时，才被迫采用并发编程。 但是Rust保证了并发代码不存在数据竞争，可以在编译时捕获任何对互斥对象或其他同步原语的误用。在RUST中，你可以使用并发编程，不必担心只有有经验的开人员才能处理好并发编程的问题。为了你必须要使用原生指针的情形，RUST提供了规避安全规则的方式。这叫做 unsafe code，虽然大部分RUST程序并不需要unsafe code，在第21章节我们将显示如何使用它，以及将说明它如何融入RUST的整体安全架构中。

 就像其他静态类型语言一样，RUST的类型不仅仅只是简单的预防未定义行为。 一个熟练的Rust程序员使用类型来确保使用的保值不仅安全而且有意义，并且与程序的设计目标保持一致。特别是在第11章节将要介绍的 "特性"和“泛型”功能，他们展示了RUST语言的简洁，灵活和高性能的特性，而且是一组类型共有的特性以及如何利用这些共有特性的优势。

我们这边书的目的给你一些见解，你没必要立刻用RUST编程。工作中用RUST编程可以确保程序的安全正确，而且同时可以预期程序的运行效果。按我们的编程经验来说，RUST是系统编程领域的重大进步，而且我们会帮助你利用它的优势来编程。

